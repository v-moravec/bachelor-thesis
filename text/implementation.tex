%! Author = Vojta
%! Date = 25.11.2021

\chapter{Implementace}
Tato kapitola popisuje tvoření protypu aplikace od založení projektu po vydání první verze. Zmíním zajímavé problémy,
které během implementace nastaly a jak jsem je řešil. Vše staví na předchozích kapitolách, tedy analýze, návrhu a použití
technologií, které jsem představil dříve.

\section{Založení projektu}
Před touto prací jsem neměl žádné zkušenosti se zakládáním větších projektů. Domluvil jsem se tedy s vedoucím a společně
jsme založili projekt pro \emph{Vue} aplikaci. Měli jsme již připravený \emph{Github} repozitář, ve kterém jsme projekt
verzovali.

Pro založení jsme využili \emph{vue ui}, což je grafické rozhraní pro správu \emph{Vue} projektů. Zde jsme zvolili konfiguraci
a přidali pluginy. Poté bylo potřeba některé z nich inicializovat.

\subsection{Firebase}
Nejdříve jsme založili projekt ve \emph{Firebase}. Stačí se přihlásit, otevřít konzoli a kliknout na tlačítko pro vytvoření projektu.
Poté se zadá název, popřípadě se projde konfigurací \emph{Google Analytics}. Rovnou jsme přešli na \emph{Blaze plan}, díky kterému
se otevřelo více možností. Je ale potřeba si kontrolovat, že aplikace nepřesáhne žádné limity~\cite{FirebaseLimits}, jinak se strhne
částka ze zadané platební karty.

Po založení se do projektu přidá aplikace. Díky tomu \emph{Firebase} vygeneruje kód, který se musí do aplikace přidat.
Pomocí \mintinline{console}|npm install firebase| se do projektu přidá potřebný balíček. Poté je potřeba přidat vygenerovaný
kód. Dále jsem nainstaloval přes \mintinline{console}|npm install -g firebase-tools| \emph{Firebase CLI}. Toto rozhraní umožní
ovládání všech služeb, které \emph{Firebase} nabízí přímo z konzole. Nakonec je nutné se přihlásit (\mintinline{console}|firebase login|) a % TODO: Popsat config?
inicializovat projekt (\mintinline{console}|firebase init|). Při inicializaci je řada možností, vybrat si které služby jsou potřeba,
a které nikoliv. Je také možné nastavit automatický \emph{deploy} při nahrání kódu na \emph{Github}.

\subsection{Automatický deploy}
Je velmi pohodlné, když se při změně kódu automaticky nahraje nová verze i na produkci. Proto jsem tuto funkci nastavil hned
při zakládání projektu a po celou dobu vývoje, jsem měl do pár minut po nahrání dostupnou verzi pro testování odkudkoliv.

Při \mintinline{console}|firebase init| se vytvoří \emph{yml} soubory v složce \emph{.github}. Díky těmto souborům se pak při
\emph{pull requestu} nebo \emph{merge} spustí proces, který sestaví aplikaci a výsledný \emph{build} nahraje na \emph{Firebase Hosting}.


\section{Struktura projektu}
Vytvoření složek a základní rozdělení jsem ponechal na \emph{vue ui}. Konfigurační soubory se nachází v \emph{rootu} projektu, implementace
je poté rozdělena podle zaměření ve složce \textbf{src}. Dále se při přidání \emph{Firebase Functions} objevila složka \textbf{functions}, která
obsahuje kód, který se nahrává na server a dá se poté využít jako jednoduché API. Složka \textbf{public} obsahuje základní soubory, jako je \textbf{index.html},
do kterého se při přístupu na stránku vloží JavaScriptový kód nebo různé ikony, jako je logo. Pro výsledný \emph{build}, který se nahraje na Firebase hosting se
používá složka \textbf{dist}.
% TODO: Vložení výpisu?

\section{Router}
% TODO: Router
Jako první věc jsem si připravil základní cesty aplikace. Cesty se přidávají jako pole objektů, kde objekt obsahuje políčka \emph{path, name, component \emph{a} meta}.
Všechny tyto parametry nejsou povinné a u některých cest jsou i další, které popíšu později. \emph{Path} je string, který následuje za adresou stránky např.
\emph{www.recipeo.cz\textbf{/example}}. \emph{Name} je název dané cesty, který se používá interně v kódu. Tato vlastnost se hodí, když programátor chce změnit adresu stránky.
Díky využití názvu cesty ji nemusí všude v aplikaci přepisovat. \emph{Component} specifikuje komponentu, která se na adrese zobrazí a \emph{meta} jsem zde využit pro změnu
titulku stránky.

Pro některé stránky bylo nutné ověřit, zda je uživatel přihlášený. K tomu lze využít \emph{navigation guards}. Tato ochrana se spustí
vždy před přístupem na stránku a vyhodnotí, zda je požadavek validní. Pokud není, uživatel je přesměrován na jinou stránku.

\begin{listing}[h]
    \caption{Příklad ochrany stránky proti nepřihlášeným uživatelům}
    \begin{minted}{js}
    async function authGuard(to, from, next) {
      if (!await Auth.getCurrentUser()) next({ name: "Login" })
      else {
        next()
      }
    }
    \end{minted}
\end{listing}

\section{Překlady}
Ačkoliv jsme se nakonec s vedoucím rozhodli aplikaci ponechat pouze v čestině, již od začátku jsem ji psal dvojjazyčně a to sice
česky a anglicky. Použil jsem plugin \emph{vue-i18n}. Pro překlady se využívají \emph{.js} soubory, ve kterých se pomocí objektů
strukturují cesty, na které se poté odkazuje ve Vue komponentách.

\begin{listing}[h]
    \caption{Překlad pro recepty}
    \begin{minted}{js}
    recipes: {
      recipes: "Recepty",
      visibility: {
        public: "Veřejný",
        private: "Soukromý",
        unlisted: "Neveřejný"
      },
      noRecipes: "Žádné recepty nenalezeny"
    }
    \end{minted}
\end{listing}

Překlad se vyvolá pomocí funkce \emph{\$t}, které se jako parametr předá cesta překladu.

\begin{listing}[h]
    \caption{Použití překladu}
    \begin{minted}{js}
    <span>{{ $t(recipes.noRecipes) }}</span>
    \end{minted}
\end{listing}

\section{Vuex}
Pomocí Vuex jsem spravoval data přímo v paměti. Vždy po spuštění aplikace se sem nahrála data receptů, ingrediencí, štítků
nebo údaje o uživateli. Pomocí \emph{actions} se volal mnou vytvořený obal pro \emph{Firestore}, odkud se stáhla data buď ze serveru
nebo s lokální cache. Poté se přes \emph{mutations} přidala nová data přímo do Vuexu. Zvolil jsem data, kterých bylo více jednoho typu,
uchovávat v objektech místo obyčejných polí. Získal jsem tím konstantní časovou složitost při přístupu k prvku přes identifikátor. Také
jsem díky tomu nemusel kontrolovat, zda recept s daným \emph{id} existuje, když se stahovala aktualizace. Recept se pouze přepsal novými
daty.

\section{PWA}
% TODO: PWA

\section{Stylování aplikace}
Vzhled aplikace se při vývoji přizpůsobil knihovně Vuetify, ale celkový koncept zůstal zachován. Některé části aplikace
se pročistily a staly se více přehledné. Začínal jsem pouze se světlým režimem, ale v průběhu jsem přidal i tmavý mód.
Bylo potřeba zvolit tmavší pozadí, tak aby bylo podobné tomu původnímu. Vytvořil jsem tedy v aplikaci Illustrator nový projekt
a pustil se do tvoření. Barvy jsem zvolil podle světlého pozadí, ale ztmavil jsem je.

Pro různé režimy jsem odlišil barvy prvků na stránce. Ve světlém jsem se rozhodl pro výrazně modrou \emph{\#1d7dee} a k tomu
pastelově zelenou \emph{\#79ffa1}, naopak v tmavém jsem použil tlumené odstíny těchto barev a to sice \emph{\#4372b4} a \emph{\#4ca262}.
Pro změnu barev jsem využil Vuetify a jeho nastavení \emph{theme}. Komponenty z Vuetify mají většinou \emph{prop color}, díky
kterému je možné změnit barvu. Pro prvky mimo Vuetify je možné využít CSS proměnné, která se automaticky vytvoří.

\section{Firebase}

\subsection{Firebase Auth}
\emph{Firebase} dokáže řešit i přihlášení uživatele. Nejprve jsem chtěl mít dva způsoby přihlášení, přes email a heslo a přes
Google. Nakonec po domluvě s vedoucím jsem zvolil prozatím ponechat pouze Google přihlášení, abychom nemuseli řešit ukládání
dat uživatele jinam než právě do \emph{Auth}. Zapnutí různých možností autentizace je možné ve webové konzoli. V případě Googlu
stačilo přidat kontaktní email a služba se spustila.

Na frontendu jsem tedy vytvořil formulář pro přihlášení a registraci. Pro budoucí využití pří případném přechodu na jinou formu
autentizace se tyto formuláře hodí. Ale v první verzi bude zpřístupněn pouze Google \emph{sign-in provider} a to sice přes \emph{pop-up},
který se uživateli zobrazí při kliknutí na tlačítko přihlášení. Metoda která tuto funkčnost poskytuje se dá naimportovat přímo
z \emph{Firebase}. Musel jsem ale upravit konfigurační soubor, ve které jsem změnil hodnotu \emph{authDomain} na \emph{recipeo.cz}.
Díky tomu se \emph{pop-up} otevře na naší doméně a ne na původní vygenerované.

\subsection{Firestore cache}
% TODO: Jak se fulltext. řešilo s Algolií
K implementaci cache jsem přistoupil, když bylo jasné, že Algolia je nepoužitelná. Musel jsem tedy vymyslet jiný způsob fulltextového
vyhledávání a jako nejlepší způsob se nabízelo stáhnou všechna potřebná data a filtr aplikovat přímo na zařízení uživatele. To je ale
spojeno s nákladnými operacemi nad databází při každém spuštění aplikace, a proto bylo nutné implementovat cache.

Základní spuštění je velmi jednoduché, stačí zavolat importovanou metodu z Firebase.

\begin{listing}[h]
    \caption{Zapnutí perzistentního módu}
    \begin{minted}{js}
    enableIndexedDbPersistence(db, {forceOwnership: true} )
    .catch((err) => {
        if (err.code === "failed-precondition") {
            console.log("Multiple tabs open, persistence can only be enabled
            in one tab at a a time.")
        } else if (err.code === "unimplemented") {
            console.log("The current browser does not support all of the
            features required to enable persistence")
        }
    })
    \end{minted}
\end{listing}

Jako parametr je potřeba předat instanci Firestore, kterou lze získat s parametrem pro neomezenou velikost, tím pádem se nebudou
mazat záznamy kvůli úspoře místa.

\begin{listing}[h]
    \caption{Získání instance Firestore}
    \begin{minted}{js}
    const db = initializeFirestore(FirebaseApp, {
        cacheSizeBytes: CACHE_SIZE_UNLIMITED
    })
    \end{minted}
\end{listing}
% TODO: Navázat na sekci z designu

Poté jsem vytvořil funkci, která se starala o to, odkud se mají data stahovat. Při každém stažení jsem si v \emph{local storage} aktualizoval
časovou značku a díky tomu jsem mohl stahovat pouze data, se kterými mezitím bylo manipulováno.

\begin{listing}[h]
    \caption{Metoda pro stažení dat}
    \begin{minted}{js}
    async getData () {
      if(!lastUpdated || !expirationDate) {
        // Download everything from server and add timestamps to localStorage.
        addTimestamps()
        Store.dispatch("getData", { source: FirestoreSource.SERVER, updateOnly: false })
        return
      }

      if(Date.now() > expirationDate) {
        // Download everything from server and add timestamps to localStorage.
        addTimestamps()
        Store.dispatch("getData", { source: FirestoreSource.SERVER, updateOnly: false })
      }
      else {
        // Get data from cache, call query to update new data and set last updated timestamp.
        localStorage.lastUpdated = Date.now()
        await Store.dispatch("getData", { source: FirestoreSource.CACHE, updateOnly: false })
        await Store.dispatch("getData", { source: FirestoreSource.SERVER, updateOnly: true })
      }
    }
    \end{minted}
\end{listing}


\subsection{Firestore rules}
Bezpečnost je důležitá součást jakéhokoliv softwaru. Firebase proto nabízí takzvané Firestore Rules pro zabezpečení dat na serveru.
Díky těmto pravidlům je možné filtrovat požadavky a v případě nutnosti zamítnout přístup k datům. Zvolil jsem pravidla na základě
indentifikace pomocí \emph{uid} neboli uživatelského identifikátoru. Pravidla fungují tak, že se pomocí cesty ve Firestore vyhledá
pravidlo a pokud je splněna podmínka, data se odešlou. Defaultně jsou všechny zdroje privátní, tedy nikdo v nim nemá přístup.

\begin{listing}[h]
    \caption{Pravidlo pro přístup k veřejnému receptu}
    \begin{minted}{js}
    match /{path=**}/recipes/{doc} {
        allow read: if resource.data.visibility == "public";
    }
    \end{minted}
\end{listing}

\subsection{Firestore Functions}
