%! Author = Vojta
%! Date = 25.11.2021

\chapter{Implementace}
Tato kapitola popisuje tvoření protypu aplikace od založení projektu po vydání první verze. Zmíním zajímavé problémy,
které během implementace nastaly a jak jsem je řešil. Vše staví na předchozích kapitolách, tedy analýze, návrhu a použití
technologií, které jsem představil dříve.

\section{Založení projektu}
Před touto prací jsem neměl žádné zkušenosti se zakládáním větších projektů. Domluvil jsem se tedy s vedoucím a společně
jsme založili projekt pro \emph{Vue} aplikaci. Měli jsme již připravený \emph{Github} repozitář, ve kterém jsme projekt
verzovali.

Pro založení jsme využili \emph{vue ui}, což je grafické rozhraní pro správu \emph{Vue} projektů. Zde jsme zvolili konfiguraci
a přidali pluginy. Poté bylo potřeba některé z nich inicializovat.

\subsection{Firebase}
Nejdříve jsme založili projekt ve \emph{Firebase}. Stačí se přihlásit, otevřít konzoli a kliknout na tlačítko pro vytvoření projektu.
Poté se zadá název, popřípadě se projde konfigurací \emph{Google Analytics}. Rovnou jsme přešli na \emph{Blaze plan}, díky kterému
se otevřelo více možností. Je ale potřeba si kontrolovat, že aplikace nepřesáhne žádné limity~\cite{FirebaseLimits}, jinak se strhne
částka ze zadané platební karty.

Po založení se do projektu přidá aplikace. Díky tomu \emph{Firebase} vygeneruje kód, který se musí do aplikace přidat.
Pomocí \mintinline{console}|npm install firebase| se do projektu přidá potřebný balíček. Poté je potřeba přidat vygenerovaný
kód. Dále jsem nainstaloval přes \mintinline{console}|npm install -g firebase-tools| \emph{Firebase CLI}. Toto rozhraní umožní
ovládání všech služeb, které \emph{Firebase} nabízí přímo z konzole. Nakonec je nutné se přihlásit (\mintinline{console}|firebase login|) a % TODO: Popsat config?
inicializovat projekt (\mintinline{console}|firebase init|). Při inicializaci je řada možností, vybrat si které služby jsou potřeba,
a které nikoliv. Je také možné nastavit automatický \emph{deploy} při nahrání kódu na \emph{Github}.

\subsection{Automatický deploy}
Je velmi pohodlné, když se při změně kódu automaticky nahraje nová verze i na produkci. Proto jsem tuto funkci nastavil hned
při zakládání projektu a po celou dobu vývoje, jsem měl do pár minut po nahrání dostupnou verzi pro testování odkudkoliv.

Při \mintinline{console}|firebase init| se vytvoří \emph{yml} soubory v složce \emph{.github}. Díky těmto souborům se pak při
\emph{pull requestu} nebo \emph{merge} spustí proces, který sestaví aplikaci a výsledný \emph{build} nahraje na \emph{Firebase Hosting}.


\section{Struktura projektu}

\section{Tvoření komponent}

\section{Firebase}

\subsection{Firebase Auth}
\emph{Firebase} dokáže řešit i přihlášení uživatele. Nejprve jsem chtěl mít dva způsoby přihlášení, přes email a heslo a přes
Google. Nakonec po domluvě s vedoucím jsem zvolil prozatím ponechat pouze Google přihlášení, abychom nemuseli řešit ukládání
dat uživatele jinam než právě do \emph{Auth}. Zapnutí různých možností autentizace je možné ve webové konzoli. V případě Googlu
stačilo přidat kontaktní email a služba se spustila.

Na frontendu jsem tedy vytvořil formulář pro přihlášení a registraci. Pro budoucí využití pří případném přechodu na jinou formu
autentizace se tyto formuláře hodí. Ale v první verzi bude zpřístupněn pouze Google \emph{sign-in provider} a to sice přes \emph{pop-up},
který se uživateli zobrazí při kliknutí na tlačítko přihlášení. Metoda která tuto funkčnost poskytuje se dá naimportovat přímo
z \emph{Firebase}. Musel jsem ale upravit konfigurační soubor, ve které jsem změnil hodnotu \emph{authDomain} na \emph{recipeo.cz}.
Díky tomu se \emph{pop-up} otevře na naší doméně a ne na původní vygenerované.

\subsection{Firestore cache}
% TODO: Jak se fulltext. řešilo s Algolií
K implementaci cache jsem přistoupil, když bylo jasné, že Algolia je nepoužitelná. Musel jsem tedy vymyslet jiný způsob fulltextového
vyhledávání a jako nejlepší způsob se nabízelo stáhnou všechna potřebná data a filtr aplikovat přímo na zařízení uživatele. To je ale
spojeno s nákladnými operacemi nad databází při každém spuštění aplikace, a proto bylo nutné implementovat cache.

Základní spuštění je velmi jednoduché, stačí zavolat importovanou metodu z Firebase.

\begin{listing}[h]
    \caption{Zapnutí perzistentního módu}
    \begin{minted}{js}
    enableIndexedDbPersistence(db, {forceOwnership: true} )
    .catch((err) => {
        if (err.code === "failed-precondition") {
            console.log("Multiple tabs open, persistence can only be enabled
            in one tab at a a time.")
        } else if (err.code === "unimplemented") {
            console.log("The current browser does not support all of the
            features required to enable persistence")
        }
    })
    \end{minted}
\end{listing}

Jako parametr je potřeba předat instanci Firestore, kterou lze získat s parametrem pro neomezenou velikost, tím pádem se nebudou
mazat záznamy kvůli úspoře místa.

\begin{listing}[h]
    \caption{Získání instance Firestore}
    \begin{minted}{js}
    const db = initializeFirestore(FirebaseApp, {
        cacheSizeBytes: CACHE_SIZE_UNLIMITED
    })
    \end{minted}
\end{listing}
% TODO: Navázat na sekci z designu

Poté jsem vytvořil funkci, která se starala o to, odkud se mají data stahovat. Při každém stažení jsem si v \emph{local storage} aktualizoval
časovou značku a díky tomu jsem mohl stahovat pouze data, se kterými mezitím bylo manipulováno.

\begin{listing}[h]
    \caption{Metoda pro stažení dat}
    \begin{minted}{js}
    async getData () {
      if(!lastUpdated || !expirationDate) {
        // Download everything from server and add timestamps to localStorage.
        addTimestamps()
        Store.dispatch("getData", { source: FirestoreSource.SERVER, updateOnly: false })
        return
      }

      if(Date.now() > expirationDate) {
        // Download everything from server and add timestamps to localStorage.
        addTimestamps()
        Store.dispatch("getData", { source: FirestoreSource.SERVER, updateOnly: false })
      }
      else {
        // Get data from cache, call query to update new data and set last updated timestamp.
        localStorage.lastUpdated = Date.now()
        await Store.dispatch("getData", { source: FirestoreSource.CACHE, updateOnly: false })
        await Store.dispatch("getData", { source: FirestoreSource.SERVER, updateOnly: true })
      }
    }
    \end{minted}
\end{listing}


\subsection{Firestore rules}
Bezpečnost je důležitá součást jakéhokoliv softwaru. Firebase proto nabízí takzvané Firestore Rules pro zabezpečení dat na serveru.
Díky těmto pravidlům je možné filtrovat požadavky a v případě nutnosti zamítnout přístup k datům. Zvolil jsem pravidla na základě
indentifikace pomocí \emph{uid} neboli uživatelského identifikátoru. Pravidla fungují tak, že se pomocí cesty ve Firestore vyhledá
pravidlo a pokud je splněna podmínka, data se odešlou. Defaultně jsou všechny zdroje privátní, tedy nikdo v nim nemá přístup.

\begin{listing}[h]
    \caption{Pravidlo pro přístup k veřejnému receptu}
    \begin{minted}{js}
    match /{path=**}/recipes/{doc} {
        allow read: if resource.data.visibility == "public";
    }
    \end{minted}
\end{listing}
